// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.15;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "./interfaces/IOutboundChannel.sol";
import "./libraries/ScaleCodec.sol";

/**
 * @dev The contract was analyzed using Slither static analysis framework. All recommendations have been taken
 * into account and some detectors have been disabled at developers' discretion using `slither-disable-next-line`.
 */
contract InboundChannel is Ownable, ReentrancyGuard {
    using ECDSA for bytes32;

    IOutboundChannel outboundChannel;
    // the last submitted batch nonce
    uint256 public batch_nonce;
    //number of authorized peers
    uint256 public peersCount;
    //indicates whether address is an authorized peer
    mapping(address => bool) public isPeer;
    //signers of the bath by batch nonce
    mapping(uint256 => mapping(address => bool)) public signedPeers;

    struct Message {
        address target;
        uint256 max_gas;
        bytes payload;
    }

    struct Batch {
        uint256 nonce;
        // Must be equal to sum of `max_gas` in `messages`
        uint256 total_max_gas;
        Message[] messages;
    }

    uint256 public constant GAS_BUFFER = 60000;

    // Batch of messages was dispatched by relayer
    // - result - message results bitmap
    // - results_length - number of messages were dispatched
    // - gas_spent - gas spent for batch submission. Since event emitted before tx committed, actual gas is greater
    // (at least 10500 gas should be added).
    // - base fee - current block base fee.
    event BatchDispatched(
        uint256 batch_nonce,
        address relayer,
        uint256 results,
        uint256 results_length,
        uint256 gas_spent,
        uint256 base_fee
    );

    event ChangePeers(address peerId, bool removal);

    constructor() {}

    // Once-off post-construction call to set initial configuration.
    function initialize(
        address _outboundChannel,
        address[] calldata initialPeers
    ) external onlyOwner {
        outboundChannel = IOutboundChannel(_outboundChannel);
        for (uint256 i; i < initialPeers.length; i++) {
            addPeer(initialPeers[i]);
        }
        // drop admin privileges
        renounceOwnership();
    }

    function submit(
        Batch calldata batch,
        uint8[] calldata v,
        bytes32[] calldata r,
        bytes32[] calldata s
    ) external nonReentrant {
        uint256 begin_gas_left = gasleft();
        require(peersCount >= 1, "peersCount too low");
        require(
            batch.messages.length < 256,
            "must be < 256 messages in the batch"
        );

        batch_nonce = batch_nonce + 1;
        // Check batch nonce is correct for replay protection
        require(batch.nonce == batch_nonce, "invalid batch nonce");

        // Since we verify that the batch was generated by substrate, we can safely
        // assume that all fields are correct (for example, `max_gas` are
        // appropriate, and `total_max_gas` = `sum(max_gas)`)
        require(
            verifySignatures(keccak256(abi.encode(batch)), v, r, s),
            "Invalid signatures"
        );

        // Require there is enough gas to execute all messages
        require(
            gasleft() >= batch.total_max_gas + GAS_BUFFER,
            "insufficient gas for delivery of all messages"
        );

        uint256 results = processMessages(batch.messages);

        uint256 gas_used = begin_gas_left - gasleft();

        emit BatchDispatched(
            batch_nonce,
            msg.sender,
            results,
            batch.messages.length,
            gas_used,
            block.basefee
        );
    }

    function addPeerByPeer(address newPeerAddress) external returns (bool) {
        require(msg.sender == address(this), "caller not this contract");

        //TODO set up call signature
        bytes memory call = abi.encodePacked(
            address(this),
            "addPeer",
            newPeerAddress
        );

        addPeer(newPeerAddress);
        emit ChangePeers(newPeerAddress, false);
        outboundChannel.submit(msg.sender, call);
        return true;
    }

    function removePeerByPeer(address peerAddress) external returns (bool) {
        require(msg.sender == address(this), "caller not this contract");

        //TODO set up call signature
        bytes memory call = abi.encodePacked(
            address(this),
            "removePeer",
            peerAddress
        );

        removePeer(peerAddress);
        emit ChangePeers(peerAddress, true);
        outboundChannel.submit(msg.sender, call);
        return true;
    }

    /**
     * Adds new peer to the list of signature verifiers.
     * Private function
     * @param newAddress address of new peer
     */
    function addPeer(address newAddress) private {
        require(isPeer[newAddress] == false, "peer already added");
        isPeer[newAddress] = true;
        ++peersCount;
    }

    /**
     * Removes a peer from the list of signature verifiers.
     * Private function
     * @param peerAddress address of the peer
     */
    function removePeer(address peerAddress) private {
        require(isPeer[peerAddress] == true, "peer does not exists");
        isPeer[peerAddress] = false;
        require(--peersCount >= 1, "cannot remove last peer");
    }

    /**
     * Checks given addresses for duplicates and if they are peers signatures
     * Batch nonce should be unique
     * @param hash signed data
     * @param v v-component of signature from hash
     * @param r r-component of signature from hash
     * @param s s-component of signature from hash
     * @return true if all given addresses are correct or false otherwise
     */
    function verifySignatures(
        bytes32 hash,
        uint8[] memory v,
        bytes32[] memory r,
        bytes32[] memory s
    ) private returns (bool) {
        uint256 signatureCount = v.length;
        require(
            signatureCount == r.length,
            "v and r length mismatch"
        );
        require(
            signatureCount == s.length,
            "v and s length mismatch"
        );
        uint256 needSigs = peersCount - (peersCount - 1) / 3;
        require(signatureCount >= needSigs, "not enough signatures");

        uint256 count;
        address[] memory recoveredAddresses = new address[](signatureCount);
        for (uint256 i; i < signatureCount; ++i) {
            address recoveredAddress = hash.toEthSignedMessageHash().recover(
                v[i],
                r[i],
                s[i]
            );

            // not a peer address or not unique
            if (
                isPeer[recoveredAddress] != true ||
                signedPeers[batch_nonce][recoveredAddress] == true
            ) {
                continue;
            }
            recoveredAddresses[count] = recoveredAddress;
            unchecked {
                count = count + 1;
            }
            signedPeers[batch_nonce][recoveredAddress] = true;
        }

        return count >= needSigs;
    }

    // - result - message results bitmap, up to 256 messages
    function processMessages(
        Message[] calldata messages
    ) private returns (uint256 results) {
        for (uint256 i = 0; i < messages.length; i++) {
            // Deliver the message to the target
            // Delivery will have fixed maximum gas allowed for the target app
            // slither-disable-next-line low-level-calls
            (bool success, ) = messages[i].target.call{
                value: 0,
                gas: messages[i].max_gas
            }(messages[i].payload);
            results |= uint256(success ? 1 : 0) << i;
        }
        return results;
    }
}
