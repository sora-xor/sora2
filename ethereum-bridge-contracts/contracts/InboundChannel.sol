// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.15;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./interfaces/IRewardSource.sol";
import "./interfaces/ISimplifiedMMRProof.sol";
import "./libraries/ScaleCodec.sol";
import "./BeefyLightClient.sol";

/** 
* @dev The contract was analyzed using Slither static analysis framework. All recommendations have been taken 
* into account and some detectors have been disabled at developers' discretion using `slither-disable-next-line`. 
*/
contract InboundChannel is AccessControl, ISimplifiedMMRProof, ReentrancyGuard {
    using ScaleCodec for uint256;
    using ScaleCodec for uint64;
    using ScaleCodec for uint32;
    using ScaleCodec for uint16;
    uint64 public nonce;

    struct Message {
        address target;
        uint64 nonce;
        uint256 fee;
        uint256 max_gas;
        bytes payload;
    }

    struct Batch {
        // Must be equal to sum of `max_gas` in `messages`
        uint256 total_max_gas;
        Message[] messages;
    }

    struct LeafBytes {
        bytes digestPrefix;
        bytes digestSuffix;
        bytes leafPrefix;
    }

    uint256 public constant GAS_BUFFER = 60000;

    // Governance contracts will administer using this role.
    bytes32 public constant CONFIG_UPDATE_ROLE =
        keccak256("CONFIG_UPDATE_ROLE");

    IRewardSource private rewardSource;

    BeefyLightClient public beefyLightClient;

    event MessageDispatched(uint64 nonce, bool result);

    constructor(address _beefyLightClient) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        beefyLightClient = BeefyLightClient(_beefyLightClient);
    }

    // Once-off post-construction call to set initial configuration.
    function initialize(address initialRewardSource)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        // Set initial configuration
        rewardSource = IRewardSource(initialRewardSource);

        // drop admin privileges
        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function submit(
        Batch calldata batch,
        LeafBytes calldata leafBytes,
        SimplifiedMMRProof calldata proof
    ) external nonReentrant {
        // Since we verify that the batch was generated by substrate, we can safely
        // assume that all fields are correct (for example, `fee`, `max_gas` are
        // appropriate, and `total_max_gas` = `sum(max_gas)`)
        verifyMerkleLeaf(batch, leafBytes, proof);

        // Require there is enough gas to execute all messages
        require(
            gasleft() >= batch.total_max_gas + GAS_BUFFER,
            "insufficient gas for delivery of all messages"
        );

        processMessages(payable(msg.sender), batch.messages);
    }

    function verifyMerkleLeaf(
        Batch calldata batch,
        LeafBytes calldata leafBytes,
        SimplifiedMMRProof calldata proof
    ) internal view {
        bytes32 commitment = keccak256(abi.encode(batch));
        bytes32 digestHash = keccak256(
            bytes.concat(
                leafBytes.digestPrefix,
                block.chainid.encode256(),
                commitment,
                leafBytes.digestSuffix
            )
        );
        bytes32 leafHash = keccak256(
            bytes.concat(leafBytes.leafPrefix, digestHash)
        );

        require(
            beefyLightClient.verifyBeefyMerkleLeaf(leafHash, proof),
            "Invalid proof"
        );
    }

    function processMessages(
        address payable relayer,
        Message[] calldata messages
    ) internal {
        uint256 rewardAmount;
        uint64 _nonce = nonce; 
        for (uint256 i = 0; i < messages.length; i++) {
            // Check message nonce is correct and increment nonce for replay protection
            require(messages[i].nonce == _nonce + 1, "invalid nonce");

            _nonce = _nonce + 1;

            // Deliver the message to the target
            // Delivery will have fixed maximum gas allowed for the target app
            // slither-disable-next-line low-level-calls
            (bool success, ) = messages[i].target.call{
                value: 0,
                gas: messages[i].max_gas
            }(messages[i].payload);
            rewardAmount = rewardAmount + messages[i].fee;
            emit MessageDispatched(messages[i].nonce, success);
        }
        nonce = _nonce;
        // reward the relayer
        rewardSource.reward(relayer, rewardAmount);
    }
}
